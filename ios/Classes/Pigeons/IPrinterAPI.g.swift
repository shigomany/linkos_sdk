// Autogenerated from Pigeon (v16.0.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Enumeration of the various printer control languages supported by Zebra Printers.
/// {@category Printer}
enum PrinterLanguage: Int {
  /// Printer control language ZPL.
  case zpl = 0
  /// Printer control language CPCL.
  case cpcl = 1
  /// Printer control language line_print mode.
  case linePrint = 2
}

/// Describe printer status.
/// {@category Printer}
enum PrinterStatus: Int {
  /// The head is cold.
  case headCold = 0
  /// The head is open.
  case headOpen = 1
  /// The head is too hot.
  case headTooHot = 2
  /// The paper is out.
  case paperOut = 3
  /// There is a partial format in progress.
  case partialFormatInProgress = 4
  /// The printer is paused.
  case paused = 5
  /// The printer reports back that it is ready to print.
  case readyToPrint = 6
  /// The receive buffer is full.
  case receiveBufferFull = 7
  /// The ribbon is out.
  case ribbonOut = 8
}

/// {@nodoc}
///
/// Generated class from Pigeon that represents data sent in messages.
struct ConnectionInfo {
  var ipAddress: String? = nil
  var macAddress: String? = nil
  var port: Int64? = nil

  static func fromList(_ list: [Any?]) -> ConnectionInfo? {
    let ipAddress: String? = nilOrValue(list[0])
    let macAddress: String? = nilOrValue(list[1])
    let port: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))

    return ConnectionInfo(
      ipAddress: ipAddress,
      macAddress: macAddress,
      port: port
    )
  }
  func toList() -> [Any?] {
    return [
      ipAddress,
      macAddress,
      port,
    ]
  }
}
private class PrinterAPICodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return ConnectionInfo.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class PrinterAPICodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? ConnectionInfo {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PrinterAPICodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PrinterAPICodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PrinterAPICodecWriter(data: data)
  }
}

class PrinterAPICodec: FlutterStandardMessageCodec {
  static let shared = PrinterAPICodec(readerWriter: PrinterAPICodecReaderWriter())
}

/// {@nodoc}
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PrinterAPI {
  /// Returns a [PrinterStatus] that can be used to determine the status of a printer.
  func currentStatus(info: ConnectionInfo) throws -> PrinterStatus
  /// Returns the printer control language (e.g. ZPL or CPCL) of the printer.
  func controlLanguage(info: ConnectionInfo) throws -> PrinterLanguage
  /// Prints an image to the connected device as a monochrome image.
  func printImage(info: ConnectionInfo, data: FlutterStandardTypedData) throws
  /// Sends the appropriate calibrate command to the printer.
  func calibrate(info: ConnectionInfo) throws
  /// Sends the appropriate print configuration command to the printer.
  func printConfigurationLabel(info: ConnectionInfo) throws
  /// Sends the appropriate restore defaults command to the printer.
  func restoreDefaults(info: ConnectionInfo) throws
  /// Converts the specified command to bytes using the Java default charset and sends the bytes to the printer.
  func sendCommand(info: ConnectionInfo, command: String) throws
  /// Sends the appropriate reset command to the printer.
  func reset(info: ConnectionInfo) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PrinterAPISetup {
  /// The codec used by PrinterAPI.
  static var codec: FlutterStandardMessageCodec { PrinterAPICodec.shared }
  /// Sets up an instance of `PrinterAPI` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PrinterAPI?) {
    /// Returns a [PrinterStatus] that can be used to determine the status of a printer.
    let currentStatusChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.linkos_sdk.PrinterAPI.currentStatus", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      currentStatusChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let infoArg = args[0] as! ConnectionInfo
        do {
          let result = try api.currentStatus(info: infoArg)
          reply(wrapResult(result.rawValue))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      currentStatusChannel.setMessageHandler(nil)
    }
    /// Returns the printer control language (e.g. ZPL or CPCL) of the printer.
    let controlLanguageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.linkos_sdk.PrinterAPI.controlLanguage", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      controlLanguageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let infoArg = args[0] as! ConnectionInfo
        do {
          let result = try api.controlLanguage(info: infoArg)
          reply(wrapResult(result.rawValue))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      controlLanguageChannel.setMessageHandler(nil)
    }
    /// Prints an image to the connected device as a monochrome image.
    let printImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.linkos_sdk.PrinterAPI.printImage", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      printImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let infoArg = args[0] as! ConnectionInfo
        let dataArg = args[1] as! FlutterStandardTypedData
        do {
          try api.printImage(info: infoArg, data: dataArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      printImageChannel.setMessageHandler(nil)
    }
    /// Sends the appropriate calibrate command to the printer.
    let calibrateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.linkos_sdk.PrinterAPI.calibrate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      calibrateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let infoArg = args[0] as! ConnectionInfo
        do {
          try api.calibrate(info: infoArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      calibrateChannel.setMessageHandler(nil)
    }
    /// Sends the appropriate print configuration command to the printer.
    let printConfigurationLabelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.linkos_sdk.PrinterAPI.printConfigurationLabel", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      printConfigurationLabelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let infoArg = args[0] as! ConnectionInfo
        do {
          try api.printConfigurationLabel(info: infoArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      printConfigurationLabelChannel.setMessageHandler(nil)
    }
    /// Sends the appropriate restore defaults command to the printer.
    let restoreDefaultsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.linkos_sdk.PrinterAPI.restoreDefaults", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      restoreDefaultsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let infoArg = args[0] as! ConnectionInfo
        do {
          try api.restoreDefaults(info: infoArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      restoreDefaultsChannel.setMessageHandler(nil)
    }
    /// Converts the specified command to bytes using the Java default charset and sends the bytes to the printer.
    let sendCommandChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.linkos_sdk.PrinterAPI.sendCommand", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      sendCommandChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let infoArg = args[0] as! ConnectionInfo
        let commandArg = args[1] as! String
        do {
          try api.sendCommand(info: infoArg, command: commandArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      sendCommandChannel.setMessageHandler(nil)
    }
    /// Sends the appropriate reset command to the printer.
    let resetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.linkos_sdk.PrinterAPI.reset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let infoArg = args[0] as! ConnectionInfo
        do {
          try api.reset(info: infoArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      resetChannel.setMessageHandler(nil)
    }
  }
}
